<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Time Space Trade-Off Euklidean Minimum Spanningtree: include/Edge.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Time Space Trade-Off Euklidean Minimum Spanningtree
   &#160;<span id="projectnumber">0.6.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Edge.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="_point_8hpp_source.html">Point.hpp</a>&quot;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for Edge.hpp:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 1 -->
</div>
</div>
</div>
<p><a href="_edge_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_edge.html">Edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Die Struktur <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Pointer auf den Vorgänger und Nachfolger in ihrem face-cycle. Damit diese nur einmal betrachtet werden, wird eine boolesche Variable visited eingeführt. Eine <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> kann gleichzeitig eine gewöhnliche Kante der Länge comprLength=1 sein, oder eine compressedEdge der Länge comprLength&gt;1. Da in dem Hilfsgraphen G eine gerichtete Kante bis zu zweimal vorkommen kann und eine Ordnung darüber definiert werden soll, wird das Set von Edges in G mit dem Attribut again aus <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> als Multiset simuliert.  <a href="struct_edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a89b91ff6921535d9c8215110f215c2c7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#a89b91ff6921535d9c8215110f215c2c7">Edge</a></td></tr>
<tr class="memdesc:a89b91ff6921535d9c8215110f215c2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Die Struktur <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Pointer auf den Vorgänger und Nachfolger in ihrem face-cycle. Damit diese nur einmal betrachtet werden, wird eine boolesche Variable visited eingeführt. Eine <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> kann gleichzeitig eine gewöhnliche Kante der Länge comprLength=1 sein, oder eine compressedEdge der Länge comprLength&gt;1. Da in dem Hilfsgraphen G eine gerichtete Kante bis zu zweimal vorkommen kann und eine Ordnung darüber definiert werden soll, wird das Set von Edges in G mit dem Attribut again aus <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> als Multiset simuliert.  <a href="_edge_8hpp.html#a89b91ff6921535d9c8215110f215c2c7">More...</a><br /></td></tr>
<tr class="separator:a89b91ff6921535d9c8215110f215c2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a342bd6483dcb66cf0d7ca5c9ed7a2a8d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#a342bd6483dcb66cf0d7ca5c9ed7a2a8d">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="struct_edge.html">Edge</a> e)</td></tr>
<tr class="memdesc:a342bd6483dcb66cf0d7ca5c9ed7a2a8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Überschreibe den Einfügeoperator, sodass eine Kante über ihre Endpunkte als (tail, head) ausgegeben wird.  <a href="_edge_8hpp.html#a342bd6483dcb66cf0d7ca5c9ed7a2a8d">More...</a><br /></td></tr>
<tr class="separator:a342bd6483dcb66cf0d7ca5c9ed7a2a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f62dc93f3810dedf600e1890d0a01a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#a02f62dc93f3810dedf600e1890d0a01a">operator==</a> (const <a class="el" href="struct_edge.html">Edge</a> &amp;e1, const <a class="el" href="struct_edge.html">Edge</a> &amp;e2)</td></tr>
<tr class="memdesc:a02f62dc93f3810dedf600e1890d0a01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Überschreibe den "==" Operator. Zwei Kanten sind genau dann identisch, wenn sie den gleichen tail, head und die gleiche Anzahl comprLength an Kanten in ihrem face-cycle haben.  <a href="_edge_8hpp.html#a02f62dc93f3810dedf600e1890d0a01a">More...</a><br /></td></tr>
<tr class="separator:a02f62dc93f3810dedf600e1890d0a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1d947f208d0ba281c45ec9717522d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#aab1d947f208d0ba281c45ec9717522d6">operator&lt;</a> (const <a class="el" href="struct_edge.html">Edge</a> &amp;e1, const <a class="el" href="struct_edge.html">Edge</a> &amp;e2)</td></tr>
<tr class="memdesc:aab1d947f208d0ba281c45ec9717522d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Überschreibe den "&lt;" Operator, sodass eine Kante e1 kleiner ist als eine Kante e2, wenn diese kürzer ist, oder bei Gleichheit von dem kleineren Punkt aus gerichtet ist. Sind diese Werte auch gleich, ist eine Kante kleiner, wenn sie eine kürzere komprimierte Länge hat. Ansonsten wird über again verglichen.  <a href="_edge_8hpp.html#aab1d947f208d0ba281c45ec9717522d6">More...</a><br /></td></tr>
<tr class="separator:aab1d947f208d0ba281c45ec9717522d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8102493a4817688f7776469f047dd1ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#a8102493a4817688f7776469f047dd1ab">operator&gt;</a> (const <a class="el" href="struct_edge.html">Edge</a> &amp;e1, const <a class="el" href="struct_edge.html">Edge</a> &amp;e2)</td></tr>
<tr class="memdesc:a8102493a4817688f7776469f047dd1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Überschreibe den "&gt;" Operator gemäß des "&lt;" Operators, wobei e1 &gt; e2 mit e2 &lt; e1 umgesetzt wird.  <a href="_edge_8hpp.html#a8102493a4817688f7776469f047dd1ab">More...</a><br /></td></tr>
<tr class="separator:a8102493a4817688f7776469f047dd1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af020e0df7bef5075b69920cf98e56dec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#af020e0df7bef5075b69920cf98e56dec">isValidEdge</a> (<a class="el" href="struct_edge.html">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:af020e0df7bef5075b69920cf98e56dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prüfe, ob die Kante valide ist, also ob die Länge != 0 ist.  <a href="_edge_8hpp.html#af020e0df7bef5075b69920cf98e56dec">More...</a><br /></td></tr>
<tr class="separator:af020e0df7bef5075b69920cf98e56dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5c8dfcd02dc870efc599cbddb41f42"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#a6a5c8dfcd02dc870efc599cbddb41f42">chooseLongerEdges</a> (const std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; &amp;actEdges, double upperLength)</td></tr>
<tr class="memdesc:a6a5c8dfcd02dc870efc599cbddb41f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Berechne alle Kanten aus actEdges, die länger als upperLength sind.  <a href="_edge_8hpp.html#a6a5c8dfcd02dc870efc599cbddb41f42">More...</a><br /></td></tr>
<tr class="separator:a6a5c8dfcd02dc870efc599cbddb41f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7aef5834315d91165c9b0f84d551fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#ae7aef5834315d91165c9b0f84d551fde">nextEdge</a> (double upperLength, const <a class="el" href="struct_edge.html">Edge</a> ej, const std::vector&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;adjacentPoints)</td></tr>
<tr class="memdesc:ae7aef5834315d91165c9b0f84d551fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Berechne die nächste Kante von e_j auf dem face-cycle von e_j, wobei nur die adjazenten Punkte aus RNG_i in Frage kommen. Diese werden aus adjacentPoints extrahiert, indem diese mit upperLength verglichen werden.  <a href="_edge_8hpp.html#ae7aef5834315d91165c9b0f84d551fde">More...</a><br /></td></tr>
<tr class="separator:ae7aef5834315d91165c9b0f84d551fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d9e141ce167e2d464105cca6530d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_edge_8hpp.html#af4d9e141ce167e2d464105cca6530d8f">succEdge</a> (double upperLength, const <a class="el" href="struct_edge.html">Edge</a> ej, const std::vector&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;adjacentPoints)</td></tr>
<tr class="memdesc:af4d9e141ce167e2d464105cca6530d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Berechne die im Uhrzeigersinn nächste Kante zu e_j, wobei nur die adjazenten Punkte aus RNG_i in Frage kommen. Diese werden aus adjacentPoints extrahiert, indem diese mit upperLength verglichen werden.  <a href="_edge_8hpp.html#af4d9e141ce167e2d464105cca6530d8f">More...</a><br /></td></tr>
<tr class="separator:af4d9e141ce167e2d464105cca6530d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a89b91ff6921535d9c8215110f215c2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b91ff6921535d9c8215110f215c2c7">&#9670;&nbsp;</a></span>Edge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_edge.html">Edge</a> <a class="el" href="struct_edge.html">Edge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Die Struktur <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Pointer auf den Vorgänger und Nachfolger in ihrem face-cycle. Damit diese nur einmal betrachtet werden, wird eine boolesche Variable visited eingeführt. Eine <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> kann gleichzeitig eine gewöhnliche Kante der Länge comprLength=1 sein, oder eine compressedEdge der Länge comprLength&gt;1. Da in dem Hilfsgraphen G eine gerichtete Kante bis zu zweimal vorkommen kann und eine Ordnung darüber definiert werden soll, wird das Set von Edges in G mit dem Attribut again aus <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> als Multiset simuliert. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6a5c8dfcd02dc870efc599cbddb41f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5c8dfcd02dc870efc599cbddb41f42">&#9670;&nbsp;</a></span>chooseLongerEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_edge.html">Edge</a>&gt; chooseLongerEdges </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>actEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upperLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Berechne alle Kanten aus actEdges, die länger als upperLength sind. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">actEdges</td><td>Vektor an zu prüfenden Kanten </td></tr>
    <tr><td class="paramname">upperLength</td><td>Die Länge der Kante bezüglich der verglichen wird </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>gebe alle Kanten aus actEdges in einem Vektor zurück, die länger als upperLength sind </dd></dl>

</div>
</div>
<a id="af020e0df7bef5075b69920cf98e56dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af020e0df7bef5075b69920cf98e56dec">&#9670;&nbsp;</a></span>isValidEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isValidEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prüfe, ob die Kante valide ist, also ob die Länge != 0 ist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>Kante </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gibt zurück, ob die <a class="el" href="struct_edge.html" title="Die Struktur Edge repräsentiert eine gerichtete Kante vom Punkt tail zu head. Jede Kante hat einen Po...">Edge</a> eine valide Kante aus disjunkten Punkten ist </dd></dl>

</div>
</div>
<a id="ae7aef5834315d91165c9b0f84d551fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7aef5834315d91165c9b0f84d551fde">&#9670;&nbsp;</a></span>nextEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_edge.html">Edge</a> nextEdge </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upperLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>ej</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacentPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Berechne die nächste Kante von e_j auf dem face-cycle von e_j, wobei nur die adjazenten Punkte aus RNG_i in Frage kommen. Diese werden aus adjacentPoints extrahiert, indem diese mit upperLength verglichen werden. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperLength</td><td>Länge der längsten Kante des aktuellen RNG_i </td></tr>
    <tr><td class="paramname">ej</td><td>Kante im RNG_i, für die die nächste Kante gesucht ist </td></tr>
    <tr><td class="paramname">adjacentPoints</td><td>Vektor an adjazenten Punkten zum head von e_j im <a class="el" href="class_r_n_g.html" title="Die Klasse RNG dient zur Berechnung und Speicherung eines Relativen Nachbarschaftsgraphen,...">RNG</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>die nächste Kante von e_j im RNG_i </dd></dl>

</div>
</div>
<a id="aab1d947f208d0ba281c45ec9717522d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1d947f208d0ba281c45ec9717522d6">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Überschreibe den "&lt;" Operator, sodass eine Kante e1 kleiner ist als eine Kante e2, wenn diese kürzer ist, oder bei Gleichheit von dem kleineren Punkt aus gerichtet ist. Sind diese Werte auch gleich, ist eine Kante kleiner, wenn sie eine kürzere komprimierte Länge hat. Ansonsten wird über again verglichen. </p>

</div>
</div>
<a id="a342bd6483dcb66cf0d7ca5c9ed7a2a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a342bd6483dcb66cf0d7ca5c9ed7a2a8d">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Überschreibe den Einfügeoperator, sodass eine Kante über ihre Endpunkte als (tail, head) ausgegeben wird. </p>

</div>
</div>
<a id="a02f62dc93f3810dedf600e1890d0a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f62dc93f3810dedf600e1890d0a01a">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Überschreibe den "==" Operator. Zwei Kanten sind genau dann identisch, wenn sie den gleichen tail, head und die gleiche Anzahl comprLength an Kanten in ihrem face-cycle haben. </p>
<p>Überschreibe den "==" Operator. Zwei Kanten sind genau dann identisch, wenn sie den gleichen tail, head und die gleiche Anzahl comprLength an Kanten in ihrem face-cycle haben. </p>

</div>
</div>
<a id="a8102493a4817688f7776469f047dd1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8102493a4817688f7776469f047dd1ab">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Überschreibe den "&gt;" Operator gemäß des "&lt;" Operators, wobei e1 &gt; e2 mit e2 &lt; e1 umgesetzt wird. </p>

</div>
</div>
<a id="af4d9e141ce167e2d464105cca6530d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d9e141ce167e2d464105cca6530d8f">&#9670;&nbsp;</a></span>succEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_edge.html">Edge</a> succEdge </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upperLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_edge.html">Edge</a>&#160;</td>
          <td class="paramname"><em>ej</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>adjacentPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Berechne die im Uhrzeigersinn nächste Kante zu e_j, wobei nur die adjazenten Punkte aus RNG_i in Frage kommen. Diese werden aus adjacentPoints extrahiert, indem diese mit upperLength verglichen werden. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upperLength</td><td>Länge der längsten Kante des aktuellen RNG_i </td></tr>
    <tr><td class="paramname">ej</td><td>Kante, die nicht im RNG_i liegt, für die der Nachfolger im RNG_i gesucht ist </td></tr>
    <tr><td class="paramname">adjacentPoints</td><td>Vektor an adjazenten Punkten zum head von e_j im <a class="el" href="class_r_n_g.html" title="Die Klasse RNG dient zur Berechnung und Speicherung eines Relativen Nachbarschaftsgraphen,...">RNG</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>die nachfolgende Kante von e_j im RNG_i </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
