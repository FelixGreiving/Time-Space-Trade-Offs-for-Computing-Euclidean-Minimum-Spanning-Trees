<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Time Space Trade-Off Euklidean Minimum Spanningtree: src/utils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Time Space Trade-Off Euklidean Minimum Spanningtree
   &#160;<span id="projectnumber">0.6.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">utils.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="utils_8hpp_source.html">utils.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for utils.cpp:</div>
<div class="dyncontent">
<div class="center"><!-- SVG 0 -->
</div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aff18024f8088d69c4f7b641f3e2f7911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#aff18024f8088d69c4f7b641f3e2f7911">rotatePoints</a> (std::set&lt; K::Point_3 &gt; &amp;inputPoints, <a class="el" href="class_transformer.html">Transformer</a> &amp;transformer, std::vector&lt; K::Point_3 &gt; &amp;vecPoints)</td></tr>
<tr class="memdesc:aff18024f8088d69c4f7b641f3e2f7911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drehe alle Eingabepunkte um den Winkel k*60° und speichere diese in dem Vektor vecPoints.  <a href="utils_8cpp.html#aff18024f8088d69c4f7b641f3e2f7911">More...</a><br /></td></tr>
<tr class="separator:aff18024f8088d69c4f7b641f3e2f7911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e679d3f6ad230aa35d831d6c4cf1c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#ab3e679d3f6ad230aa35d831d6c4cf1c2">binarySearch</a> (std::vector&lt; K::Point_3 &gt; &amp;vecPoints, double xCoord, double yCoord)</td></tr>
<tr class="memdesc:ab3e679d3f6ad230aa35d831d6c4cf1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gebe zurück, ob (xCoord, yCoord) in vecPoints liegt.  <a href="utils_8cpp.html#ab3e679d3f6ad230aa35d831d6c4cf1c2">More...</a><br /></td></tr>
<tr class="separator:ab3e679d3f6ad230aa35d831d6c4cf1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b38e5219336f4d2902c99e79b09f05b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#a2b38e5219336f4d2902c99e79b09f05b">minBinarySearch</a> (std::vector&lt; K::Point_3 &gt; &amp;vecPoints, double xCoord, double yCoord)</td></tr>
<tr class="memdesc:a2b38e5219336f4d2902c99e79b09f05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gebe den Index des minimalen Punktes unter allen Punkten, die größer als (xCoord, yCoord) sind, zurück. Laut Voraussetzung ist (xCoord, yCoord) in vecPoints enthalten, oder kleiner als der größte Punkte in vecPoints.  <a href="utils_8cpp.html#a2b38e5219336f4d2902c99e79b09f05b">More...</a><br /></td></tr>
<tr class="separator:a2b38e5219336f4d2902c99e79b09f05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467dde9348de2a2f78ec2f7234c8129e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#a467dde9348de2a2f78ec2f7234c8129e">maxBinarySearch</a> (std::vector&lt; K::Point_3 &gt; &amp;vecPoints, double xCoord, double yCoord)</td></tr>
<tr class="memdesc:a467dde9348de2a2f78ec2f7234c8129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gebe den Index des maximalen Punktes unter allen Punkten, die kleiner als (xCoord, yCoord) sind, zurück. Laut Voraussetzung ist (xCoord, yCoord) in vecPoints enthalten oder größer als der kleinste Punkt in vecPoints.  <a href="utils_8cpp.html#a467dde9348de2a2f78ec2f7234c8129e">More...</a><br /></td></tr>
<tr class="separator:a467dde9348de2a2f78ec2f7234c8129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b10896e6f91ffd91a0ea312c22dce5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#a1b10896e6f91ffd91a0ea312c22dce5e">findMedian</a> (std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; vec)</td></tr>
<tr class="memdesc:a1b10896e6f91ffd91a0ea312c22dce5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Berechnet für einen Vektor an Kanten den Median.  <a href="utils_8cpp.html#a1b10896e6f91ffd91a0ea312c22dce5e">More...</a><br /></td></tr>
<tr class="separator:a1b10896e6f91ffd91a0ea312c22dce5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eb5cd520434504f99c2f58b25f96ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#a52eb5cd520434504f99c2f58b25f96ed">findMedianOfMedians</a> (std::vector&lt; std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt;&gt; values)</td></tr>
<tr class="memdesc:a52eb5cd520434504f99c2f58b25f96ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Berechnet für einen Vektor von Vektoren an Kanten den Median der Mediane.  <a href="utils_8cpp.html#a52eb5cd520434504f99c2f58b25f96ed">More...</a><br /></td></tr>
<tr class="separator:a52eb5cd520434504f99c2f58b25f96ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ded6ac152c5545d79e395774c0a92d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_edge.html">Edge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#ad9ded6ac152c5545d79e395774c0a92d">selectKthElement</a> (const std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; &amp;values, int k)</td></tr>
<tr class="memdesc:ad9ded6ac152c5545d79e395774c0a92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Berechnet das k-te Element des Vektors temp.  <a href="utils_8cpp.html#ad9ded6ac152c5545d79e395774c0a92d">More...</a><br /></td></tr>
<tr class="separator:ad9ded6ac152c5545d79e395774c0a92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f7ea9bbe0f08dc15614c06b76335ed"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#ab0f7ea9bbe0f08dc15614c06b76335ed">unionOfSets</a> (const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;Q, const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;R)</td></tr>
<tr class="memdesc:ab0f7ea9bbe0f08dc15614c06b76335ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bildet die Vereinigung der zwei Punktmengen Q und R.  <a href="utils_8cpp.html#ab0f7ea9bbe0f08dc15614c06b76335ed">More...</a><br /></td></tr>
<tr class="separator:ab0f7ea9bbe0f08dc15614c06b76335ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ab07799c4cc63faa1dd0f213539fec"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cpp.html#a53ab07799c4cc63faa1dd0f213539fec">unionOfSets</a> (const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;Q, const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;R, const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;N)</td></tr>
<tr class="memdesc:a53ab07799c4cc63faa1dd0f213539fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bildet die Vereinigung der drei Punktmengen P, Q und R.  <a href="utils_8cpp.html#a53ab07799c4cc63faa1dd0f213539fec">More...</a><br /></td></tr>
<tr class="separator:a53ab07799c4cc63faa1dd0f213539fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab3e679d3f6ad230aa35d831d6c4cf1c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e679d3f6ad230aa35d831d6c4cf1c2">&#9670;&nbsp;</a></span>binarySearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool binarySearch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; K::Point_3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gebe zurück, ob (xCoord, yCoord) in vecPoints liegt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecPoints</td><td>Vektor von assPoints, der umgekehrt lexikographisch sortiert ist und mindestens ein Element enthält </td></tr>
    <tr><td class="paramname">xCoord</td><td>x-Koordinate des gesuchten Punktes </td></tr>
    <tr><td class="paramname">yCoord</td><td>y-Koordinate des gesuchten Punktes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gibt zurück, ob der Punkt (xCoord, yCoord) in vecPoints liegt </dd></dl>

</div>
</div>
<a id="a1b10896e6f91ffd91a0ea312c22dce5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b10896e6f91ffd91a0ea312c22dce5e">&#9670;&nbsp;</a></span>findMedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_edge.html">Edge</a> findMedian </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Berechnet für einen Vektor an Kanten den Median. </p>
<p>Berechnet für einen Vektor an Kanten den Median bzgl. der "&lt;" Ordnung.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>Vektor an Kanten </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Die Kante, die dem Median in vec entspricht </dd></dl>

</div>
</div>
<a id="a52eb5cd520434504f99c2f58b25f96ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52eb5cd520434504f99c2f58b25f96ed">&#9670;&nbsp;</a></span>findMedianOfMedians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_edge.html">Edge</a> findMedianOfMedians </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt;&gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Berechnet für einen Vektor von Vektoren an Kanten den Median der Mediane. </p>
<p>Berechnet für einen Vektor von Vektoren an Kanten den Median der Mediane bzgl. der "&lt;" Ordnung.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>Vektor der an jeder Position einen Vektor aus 5 Kanten enthält </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kante, die dem Median der Mediane der übergebenen Kanten entspricht </dd></dl>

</div>
</div>
<a id="a467dde9348de2a2f78ec2f7234c8129e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467dde9348de2a2f78ec2f7234c8129e">&#9670;&nbsp;</a></span>maxBinarySearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int maxBinarySearch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; K::Point_3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gebe den Index des maximalen Punktes unter allen Punkten, die kleiner als (xCoord, yCoord) sind, zurück. Laut Voraussetzung ist (xCoord, yCoord) in vecPoints enthalten oder größer als der kleinste Punkt in vecPoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecPoints</td><td>Vektor von assPoints, der umgekehrt lexikographisch sortiert ist und mindestens ein Element enthält </td></tr>
    <tr><td class="paramname">xCoord</td><td>x-Koordinate des zu vergleichenden Punktes </td></tr>
    <tr><td class="paramname">yCoord</td><td>y-Koordinate des zu vergleichenden Punktes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index an dessen Position der maximale Punkt unter den kleineren Punkten als (xCoord, yCoord) in vecPoints liegt <br  />
 </dd></dl>

</div>
</div>
<a id="a2b38e5219336f4d2902c99e79b09f05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b38e5219336f4d2902c99e79b09f05b">&#9670;&nbsp;</a></span>minBinarySearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int minBinarySearch </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; K::Point_3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xCoord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yCoord</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gebe den Index des minimalen Punktes unter allen Punkten, die größer als (xCoord, yCoord) sind, zurück. Laut Voraussetzung ist (xCoord, yCoord) in vecPoints enthalten, oder kleiner als der größte Punkte in vecPoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecPoints</td><td>Vektor von assPoints, der umgekehrt lexikographisch sortiert ist und mindestens ein Element enthält </td></tr>
    <tr><td class="paramname">xCoord</td><td>x-Koordinate des zu vergleichenden Punktes </td></tr>
    <tr><td class="paramname">yCoord</td><td>y-Koordinate des zu vergleichenden Punktes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index an dessen Position der minimalen Punkts unter den größeren Punkten als (xCoord, yCoord) in vecPoints liegt <br  />
 </dd></dl>

</div>
</div>
<a id="aff18024f8088d69c4f7b641f3e2f7911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff18024f8088d69c4f7b641f3e2f7911">&#9670;&nbsp;</a></span>rotatePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rotatePoints </td>
          <td>(</td>
          <td class="paramtype">std::set&lt; K::Point_3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_transformer.html">Transformer</a> &amp;&#160;</td>
          <td class="paramname"><em>transformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; K::Point_3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drehe alle Eingabepunkte um den Winkel k*60° und speichere diese in dem Vektor vecPoints. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputPoint</td><td>Menge an Eingabepunkten </td></tr>
    <tr><td class="paramname">transformer</td><td>Transformationsobjekt zur Drehung der Eingabepunkte </td></tr>
    <tr><td class="paramname">vecPoints</td><td>Referenz auf Vektor von Punkten, in den die gedrehten Punkte eingefügt werden können </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9ded6ac152c5545d79e395774c0a92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ded6ac152c5545d79e395774c0a92d">&#9670;&nbsp;</a></span>selectKthElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_edge.html">Edge</a> selectKthElement </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Berechnet das k-te Element des Vektors temp. </p>
<p>Berechnet das k-te Element bzgl. "&lt;" des Vektors temp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">temp</td><td>Vektor an Kanten </td></tr>
    <tr><td class="paramname">k</td><td>Die k-te größte Kante ist gesucht </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Die k-te größte Kante aus dem Vektor temp </dd></dl>

</div>
</div>
<a id="ab0f7ea9bbe0f08dc15614c06b76335ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f7ea9bbe0f08dc15614c06b76335ed">&#9670;&nbsp;</a></span>unionOfSets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="struct_point.html">Point</a>&gt; unionOfSets </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bildet die Vereinigung der zwei Punktmengen Q und R. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>erste Punktmenge </td></tr>
    <tr><td class="paramname">R</td><td>zweite Punktmenge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gibt die Vereinigung der Punktmengen zurück </dd></dl>

</div>
</div>
<a id="a53ab07799c4cc63faa1dd0f213539fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ab07799c4cc63faa1dd0f213539fec">&#9670;&nbsp;</a></span>unionOfSets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="struct_point.html">Point</a>&gt; unionOfSets </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bildet die Vereinigung der drei Punktmengen P, Q und R. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>erste Punktmenge </td></tr>
    <tr><td class="paramname">R</td><td>zweite Punktmenge </td></tr>
    <tr><td class="paramname">N</td><td>dritte Punktmenge </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Gibt die Vereinigung der Punktmengen zurück </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
